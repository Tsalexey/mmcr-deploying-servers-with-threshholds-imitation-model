import sys

sys.path.append('../')
from core.states import States

__author__ = 'tsarev alexey'
#--------------------------------------------------------------------------------------------------------------------#
#													   GENERATED_VALUES_STORAGE										 #
#--------------------------------------------------------------------------------------------------------------------#
class Generated_values_storage:
	"""
		This class is designed to store data generated by simulation
	"""
	def __init__(self):
		self.lambd = 0
		self.mu = 0
		self.theta = 0
		self.servers_count = 0
		self.core_servers_count = 0
		self.L = 0
		self.H = 0
		self.simulation_time = 0
		self.time = 0
		self.is_debug = False
		self.blocked = 0
		self.served = 0
		self.generated = 0
		self.B = 0
		self.W_system = 0
		self.N = 0
		self.W_queue = 0
		self.Q = 0
		self.state_time = dict.fromkeys(States.get_States_list(States), 0)
		self.state_count = dict.fromkeys(States.get_States_list(States), 0)
		self.up_down_mean = 0;
		self.up_down_count = 0


	def add(self, simulation):
		"""
			Add data from simulation
		"""
		self.lambd = simulation.lambd
		self.mu = simulation.mu
		self.theta = simulation.theta
		self.servers_count = simulation.servers_count
		self.core_servers_count = simulation.core_servers_count
		self.L = simulation.L
		self.H = simulation.H
		self.simulation_time = simulation.simulation_time
		self.time += simulation.time
		self.is_debug = simulation.is_debug

		temp_blocked = simulation.queue.blocked;
		temp_served = simulation.served_count;
		temp_served_w = simulation.served_sum_w;
		temp_served_wq = simulation.served_sum_wq;

		self.blocked += temp_blocked
		self.served += temp_served
		self.generated += simulation.flow.generated_count

		self.B += temp_blocked / (temp_blocked + temp_served)
		self.W_system += temp_served_w / temp_served;
		self.N += (temp_served_w / (temp_served + temp_blocked)) * self.lambd

		self.W_queue += temp_served_wq / temp_served;
		self.Q += (temp_served_wq / (temp_served + temp_blocked)) * self.lambd

		for state in States.get_States_list(States):
			self.state_time[state] += simulation.state_time[state]
			self.state_count[state] += simulation.state_count[state]

		self.up_down_mean += simulation.up_down_mean
		self.up_down_count += simulation.up_down_count

	def normalize(self, repeats):
		"""
			Normalize data if there was more then one repeats
		"""
		self.blocked /= repeats
		self.served /= repeats
		self.generated /= repeats
		self.B /= repeats
		self.N /= repeats
		self.W_system /= repeats
		self.W_queue /= repeats
		self.Q /= repeats
		self.time /= repeats
		for state in States.get_States_list(States):
			self.state_time[state] /= repeats
			self.state_count[state] /= repeats

		# get part of time for state
		t = 0
		c = 0
		for state in States.get_States_list(States):
			t += self.state_time[state]
			c += self.state_count[state]

		for state in States.get_States_list(States):
			self.state_time[state] /= t
			self.state_count[state] /= c

		self.up_down_mean /= repeats
		self.up_down_count /= repeats
